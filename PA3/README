README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

Group 12 
E/17/027
E/17/219

Design Process
--------------
	
	1.First associations for precedence in each operator was written in the cool.y file. This was done using the below format.

		%[right/left/nonassoc] [TOKEN/TOKEN_SET]

		-The association for each or set of operations was given in the cool-manual.pdf.

	2. Then all the rules related to each syntax rule were written. All of these rules were given in the cool-manual.pdf. Below 
	are the lists and different rule types we came up with.
		
		1. program
		2.class_list
		3. class
		4. feature_list
		5. features
		6. feature
		7. formal_list
		8. formal
		9. expression
		10. expr_parameters
		11. expr_statements
		12. expr_case
		13. expr_let

		-All the definitions and explanations for all the syntax rules were given in the cool.y file as comments.

	3. In addition to that, errors were handled in each syntax rule.

	4. program is the root node in the AST, which is the main node in the AST. a program can be made up of at least one class(Main class) 
	or multiple classes. Therefore the next level of the AST is simply a list of classes.

	5. In each class, there should be a class signature with the class definition in the curly braces. Class definition was considered as 
	feature_list as cool-maual.pdf suggest, therefore making feature_list as the next level of the AST.

	6. Of course, inside of a class can be empty therefore feature_list can be null. This case was handled in the rule definition of feature_list.

	7. Feature list can be made up of zero or more feature , therefore making feature as the next level of the AST.

	8. Feature can be a method or attribute. Therefore to make methods and attributes corresponding constructors were used which were specified 
	in cool-tree.h file and cool-tour.pdf.(of course for making previous rules also, appropriate constructors were used.)

	9. When there are optional extensions to the rule definition, in the constructor , no_expr() function is used to pass that parameter 
	because in the rule definition it is not available.(for ex : line number 432 in cool.y)  

	10. In the method definition of feature definition parameters of the method is taken as the formal_list, making that as the next 
	level of AST. Also expression was used while defining feature.

	11. formal was the next level of AST followed by expressions as the next level of the AST. Each of these were clearly explained in the 
	code itself and 4 more cases introduced while defining expressions which are expr_statements , expr_parameters, expr_case and expr_let , 
	,making them the next few levels of the AST of the parser.

	12. expression is the longest part of the as per the definition, because most codes will of course contain expressions in most lines in different forms.

	13. When defining single cases and multiple cases in different lists, we used single_CASE() and append_CASES() constructors which were defined 
	in the cool-tree.h file. For example : we have used single_Classes() and single_Features() to define single classes and features and we have used 
	append_Classes() and append_Features() to construct a list of classes and features.

	14. Of course while defining the above rules, we needed to add new types in the cool.y file.(from line 137 to 154). Here, we have used what is defined 
	in the union which is defined at 89 lines. Below format is used when defining types.

		%type <[name as in the union]> [name of the type]

	15. In addition , the errors were handled. For these each error is handled using where it can occur. In total there were 7 error cases and they are 
	stated below.

		1. When there is an error in the feature_list in class definition.
		2. When there is an error in the class signature.
		3. When there is an error in the feature list or the class signature.
		4. When there is an error in the features.
		5. When there is an error in the OBJECTID ':' TYPEID section in the 
		let definition.
		6. When there is an error in the assign operation in the let 
		definition.
		7. When there is an error in the expr_statement.

		- In all of those error cases, yyerror function is called automatically by Bison and it was already defined in the cool.y file.

		- Each error is handled by using yyclearin statement which is used to clear the next token(lookahead token) which is processed by the 
		parser and then a null node is added to the parser as there is an error in the current processing node. 

Testing
-------

	1. We have tested the parser using good.cl and bad.cl codes. We have checked every syntax rule using good.cl and we have checked the
	error handling using bad.cl.

	2. For testing the good.cl file below command is used in the terminal.

		diff -y <(lexer good.cl | parser) <(lexer good.cl | ./parser)

		- Using above command we were able to compare the default parser with our implementation of the parser. We were able to see that, our
		parser generates the accurate parser tree for the code in good.cl.

	3. For testing bad.cl and check if the error hanlding works, we used below command.

		diff -y <(lexer bad.cl | parser) <(lexer bad.cl | ./parser)

		- Using above command we were able to see that our parser does additional error handling as well. Which is good because then the 
		user can get more information when debugging the code.

		- Follwoing test cases tested in bad.cl file.
			1. erroneous class definition ('inherits' is misspelled)
			2. erroneous statement definition (semicolon missing)
			3. erroneous type declaration (colon missing)
			4. both class def and statements are erroneous (misspelling and semicolon)
			5. incorrect feature definition (colon missing)
			6. erroneous 'let' statement (assignment missing)
			7. erroneous 'let' statement ('new' missing)
			8. incorrect 'case' expression (darrow missing)

	4. We used 'make dotest' command to test both good.cl and bad.cl at once. We used this usally more than above two so that we can 
	test both files.




