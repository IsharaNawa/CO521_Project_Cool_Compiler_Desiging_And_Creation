README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------

Group 12
E/17/027
E/17/219

1.Design Decisions
------------------

	A).General Design Decisions

		- All the rules related to regular expression matches are placed in the cool.flex file, with the priority in mind. 
		 Ex : if we place the identifier rule before boolean values, the flex will choose true , false as identifiers. Therefore boolean values are placed just after keywords.

		- Below are the token classes which are defined in the flex file. Note : They are displayed according to the priority
		Keywords
		Integers
		Boolean
		Identifiers
		Strings
		Whitespace
		Operators
		Comments
		Errors

		- We have specifically identified every regular expression in our Rule file. This will simplify the structure of the code.

		- Each line number in the flex file is stored in the curr_lineno variable and as one new line detects, this variable is incremented by 1. 

	B).Design Decisions related to each token class.

		1. Keywords

			-In key words, regular expressions related to each of the keywords in cool are specified and in the rule of each keyword, the keyword itself is returned. Definitions for keywords are used from the cool-parse.h file in “/cool/include/PA2”.

			-When defining regular expressions for keywords, case sensitivity is also considered.

			-Regular expressions have been defined such that the keywords will not be case sensitive.

		2. Integers

			-Regular expressions for integers are derived from the regular expression related to one digit.

			-After matching an integer, the corresponding value is written to the inttable and also the INT_CONST value is returned in the rule.

			-For integers, any number of digits is considered.

		3. Boolean

			-For booleans, true and false keywords are identified then after matching BOOL_CONST is returned.

			-Also bool is added to the table as well.

		4.Identifiers

			-There are two types of identifiers that are type and object identifiers.

			-Type identifiers are defined such that the first letter of that identifier starts with an uppercase letter and object identifiers are defined such that the first letter is a lowercase letter.

			-Those variables are added to the idtable in their corresponding rules.

			-The underscore character is taken as a valid character for Object IDs.

		5.Strings

			-At the start of a string, we redefine the char array 'string_buf_ptr', to hold the string. Since we are neglecting the previous string, we can write on top of the previous word.

			-If the string gets completed without an error, the corresponding string (i.e. string_buf) is appended to the 'stringtable'.

			-For all the characters in the string which are not going to be neglected, we check whether the total string length doesn't exceed the maximum string count (MAX_STR_CONST). If it exceeds, a custom function we built (string_length_err) will be called.

		6.Whitespace

			-There are few types of whitespaces that are considered.

			-Those are new lines and the empty space/ tabs.

			-When a new line match is found , the curr_lineno variable is incremented by 1 as it represents the line number.

			-Every other whitespace is ignored.

		7.Operators and special notations

			-Regular expressions related to all the operators and special notations were defined and in each rule , the operator itself is returned.

		8.Comments 

			-Comments matching and error handling is done using other features of flex.

			-There are two types of comments , single line and multi-line.

			-In single line comments, the regular expression is defined so that it starts with a - - and then some characters and at the end, there will be a new line character. In its’ rule, the line number is increased by 1.

			-In multiline comments, error handling is done.

			-When (* is found, the variable related to multiline comment goes high. This is done using the BEGIN method in flex. This means that the comment has opened.

			-Then after that value goes high, it is checked if there is an EOF. If so , that means, there is an EOF before the comment is closed. Here there should be an error and that error message is printed. Also the initial state of the flexer is achieved by using BEGIN(INITIAL) method.

			-Then it is checked that there is a new line after COMMENT is started. If so, the line number is incremented by 1.

			-After the COMMENT variable goes high, every character followed is disregarded until it is closed.

			-When *) is found after the COMMENT variable goes high, function call to BEGIN(INITIAL) happens and this is considered as non-erroneous commenting. If , *) is found before the COMMENT variable goes high, that means an error in commenting. Therefore an error message is printed.

		9. Errors

			-Every other token in the code is considered as error tokens since they do not belong to any of the above token classes.


2.Testing
---------

	1.To test the program we compared our lexical analyzer with the ideal one, using the following command.

		diff <(./lexer test.cl) <(lexer test.cl) -y

	2.A customized test.cl is used to expose the lexical analyzer to improve the accuracy. (Customized test.cl is attached in the tarball)
